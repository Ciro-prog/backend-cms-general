#!/usr/bin/env python3
# ================================
# fix_main_py_auth_issues.py - ARREGLAR PROBLEMAS DE AUTENTICACI√ìN
# ================================

from pathlib import Path
from datetime import datetime
import re

def fix_main_py_authentication():
    """Arreglar todos los problemas de autenticaci√≥n en main.py"""
    
    main_file = Path("app/main.py")
    
    if not main_file.exists():
        print("‚ùå main.py no existe")
        return
    
    print("üîß Arreglando problemas de autenticaci√≥n en main.py...")
    
    # Backup
    timestamp = datetime.now().strftime("%H%M%S")
    backup_path = main_file.with_suffix(f'.backup_final_{timestamp}.py')
    backup_path.write_text(main_file.read_text(encoding='utf-8'), encoding='utf-8')
    print(f"‚úÖ Backup: {backup_path.name}")
    
    content = main_file.read_text(encoding='utf-8')
    
    # ================================
    # 1. ARREGLAR ENDPOINT RA√çZ DUPLICADO
    # ================================
    
    # Remover el primer @app.get("/") que devuelve JSON
    first_root_pattern = r'@app\.get\("/"\)\s*\nasync def root\(\):\s*\n\s*return\s*\{[^}]*"message":\s*"CMS Din√°mico API"[^}]*\}'
    
    if re.search(first_root_pattern, content, re.DOTALL):
        content = re.sub(first_root_pattern, '', content, flags=re.DOTALL)
        print("‚úÖ Primer endpoint ra√≠z (JSON) eliminado")
    
    # ================================
    # 2. CREAR FUNCI√ìN DE VERIFICACI√ìN DE AUTH
    # ================================
    
    auth_function = '''
# ================================
# FUNCIONES DE AUTENTICACI√ìN
# ================================

def get_current_user(request: Request) -> Optional[Dict[str, Any]]:
    """Obtener usuario actual de la sesi√≥n"""
    if hasattr(request, 'session') and request.session.get("authenticated"):
        return request.session.get("user")
    return None

def require_auth(request: Request) -> Dict[str, Any]:
    """Requerir autenticaci√≥n - lanza excepci√≥n si no est√° logueado"""
    user = get_current_user(request)
    if not user:
        raise HTTPException(
            status_code=401,
            detail="Autenticaci√≥n requerida"
        )
    return user

def require_admin(request: Request) -> Dict[str, Any]:
    """Requerir rol admin o superior"""
    user = require_auth(request)
    if user["role"] not in ["admin", "super_admin"]:
        raise HTTPException(
            status_code=403,
            detail="Permisos de administrador requeridos"
        )
    return user
'''
    
    # Buscar d√≥nde insertar las funciones de auth (despu√©s de los imports)
    insert_point = content.find("# ================================\n# MODELOS PYDANTIC\n# ================================")
    if insert_point != -1:
        content = content[:insert_point] + auth_function + "\n" + content[insert_point:]
        print("‚úÖ Funciones de autenticaci√≥n agregadas")
    
    # ================================
    # 3. ARREGLAR ENDPOINT RA√çZ FINAL
    # ================================
    
    # Buscar el @app.get("/", include_in_schema=False) y reemplazarlo
    root_redirect_pattern = r'@app\.get\("/", include_in_schema=False\)\s*\nasync def root_redirect\(\):\s*\n\s*return RedirectResponse\(url="/login", status_code=302\)'
    
    new_root_endpoint = '''@app.get("/", response_class=HTMLResponse)
async def root(request: Request):
    """P√°gina principal - redirige seg√∫n autenticaci√≥n"""
    
    user = get_current_user(request)
    
    if user:
        # Usuario logueado - ir al dashboard
        logger.info(f"üè† Usuario {user['username']} accedi√≥ a p√°gina principal - redirigiendo a dashboard")
        return RedirectResponse(url="/dashboard", status_code=302)
    else:
        # Usuario no logueado - mostrar p√°gina de bienvenida
        logger.info("üè† Usuario an√≥nimo accedi√≥ a p√°gina principal - mostrando p√°gina de bienvenida")
        
        # Obtener informaci√≥n del sistema
        try:
            db = get_database()
            system_info = {
                "status": "running",
                "version": "1.0.0",
                "timestamp": datetime.utcnow().isoformat(),
                "total_businesses": await db.business_instances.count_documents({}),
                "active_apis": await db.api_configurations.count_documents({"active": True})
            }
        except Exception as e:
            logger.error(f"Error obteniendo info del sistema: {e}")
            system_info = {
                "status": "running",
                "version": "1.0.0", 
                "timestamp": datetime.utcnow().isoformat(),
                "error": "Error conectando a base de datos"
            }
        
        return templates.TemplateResponse("home.html", {
            "request": request,
            "system_info": system_info
        })'''
    
    if re.search(root_redirect_pattern, content, re.DOTALL):
        content = re.sub(root_redirect_pattern, new_root_endpoint, content, flags=re.DOTALL)
        print("‚úÖ Endpoint ra√≠z arreglado")
    
    # ================================
    # 4. PROTEGER DASHBOARD
    # ================================
    
    # Buscar el endpoint dashboard y agregar verificaci√≥n de auth
    dashboard_pattern = r'(@app\.get\("/dashboard", response_class=HTMLResponse\)\s*\nasync def dashboard\(request: Request\):)'
    
    if re.search(dashboard_pattern, content):
        dashboard_replacement = r'\1\n    """Dashboard principal - requiere autenticaci√≥n"""\n    \n    # Verificar autenticaci√≥n\n    user = require_auth(request)'
        content = re.sub(dashboard_pattern, dashboard_replacement, content)
        print("‚úÖ Dashboard protegido con autenticaci√≥n")
        
        # Tambi√©n actualizar el dashboard para usar el usuario real
        content = content.replace(
            'current_user = {\n        "name": "Super Admin",\n        "role": "super_admin",\n        "username": "superadmin",\n        "business_id": "isp_telconorte"\n    }',
            'current_user = user'
        )
        print("‚úÖ Dashboard usando usuario real de sesi√≥n")
    
    # ================================
    # 5. PROTEGER RUTAS DE GESTI√ìN
    # ================================
    
    # Proteger /api-management
    api_mgmt_pattern = r'(@app\.get\("/api-management", response_class=HTMLResponse\)\s*\nasync def api_management\(request: Request\):)'
    if re.search(api_mgmt_pattern, content):
        api_mgmt_replacement = r'\1\n    """Gesti√≥n de APIs - requiere admin"""\n    user = require_admin(request)\n'
        content = re.sub(api_mgmt_pattern, api_mgmt_replacement, content)
        print("‚úÖ /api-management protegido")
    
    # Proteger /api-management/wizard  
    wizard_pattern = r'(@app\.get\("/api-management/wizard", response_class=HTMLResponse\)\s*\nasync def api_wizard\(request: Request\):)'
    if re.search(wizard_pattern, content):
        wizard_replacement = r'\1\n    """Wizard de APIs - requiere admin"""\n    user = require_admin(request)\n'
        content = re.sub(wizard_pattern, wizard_replacement, content)
        print("‚úÖ /api-management/wizard protegido")
    
    # Proteger /api-management/test
    test_pattern = r'(@app\.get\("/api-management/test", response_class=HTMLResponse\)\s*\nasync def api_test_page\(request: Request\):)'
    if re.search(test_pattern, content):
        test_replacement = r'\1\n    """Test de APIs - requiere admin"""\n    user = require_admin(request)\n'
        content = re.sub(test_pattern, test_replacement, content)
        print("‚úÖ /api-management/test protegido")
    
    # ================================
    # 6. AGREGAR LOGOUT FUNCIONAL
    # ================================
    
    logout_pattern = r'@app\.post\("/logout"\)\s*\nasync def logout\(\):\s*\n\s*return RedirectResponse\(url="/login", status_code=302\)'
    
    new_logout = '''@app.post("/logout")
async def logout(request: Request):
    """Cerrar sesi√≥n"""
    user = get_current_user(request)
    
    if user:
        logger.info(f"üëã Usuario {user['username']} cerr√≥ sesi√≥n")
    
    # Limpiar sesi√≥n
    request.session.clear()
    
    return RedirectResponse(url="/login", status_code=302)'''
    
    if re.search(logout_pattern, content, re.DOTALL):
        content = re.sub(logout_pattern, new_logout, content, flags=re.DOTALL)
        print("‚úÖ Logout funcional agregado")
    
    # ================================
    # 7. AGREGAR IMPORTS NECESARIOS
    # ================================
    
    # Verificar si tiene los imports necesarios
    if 'from typing import Dict, Any, List, Optional' not in content:
        # Buscar l√≠nea de imports de typing y agregar lo que falta
        typing_pattern = r'from typing import ([^\\n]+)'
        if re.search(typing_pattern, content):
            content = re.sub(
                typing_pattern, 
                'from typing import Dict, Any, List, Optional', 
                content
            )
            print("‚úÖ Imports de typing actualizados")
    
    # ================================
    # 8. ESCRIBIR ARCHIVO ARREGLADO
    # ================================
    
    main_file.write_text(content, encoding='utf-8')
    print(f"‚úÖ {main_file} actualizado con autenticaci√≥n completa")

def test_endpoints():
    """Mostrar URLs para probar"""
    
    print(f"\nüß™ ENDPOINTS PARA PROBAR:")
    print(f"")
    print(f"üìç P√öBLICOS:")
    print(f"   üè† http://localhost:8000/ - P√°gina principal (redirige seg√∫n auth)")
    print(f"   üîë http://localhost:8000/login - Login")
    print(f"   üìö http://localhost:8000/docs - Documentaci√≥n API")
    print(f"   ‚ù§Ô∏è http://localhost:8000/health - Estado del sistema")
    print(f"")
    print(f"üîê REQUIEREN LOGIN:")
    print(f"   üìä http://localhost:8000/dashboard - Dashboard (cualquier usuario)")
    print(f"")
    print(f"üëë REQUIEREN ADMIN:")
    print(f"   ‚öôÔ∏è http://localhost:8000/api-management - Gesti√≥n de APIs")
    print(f"   üßô http://localhost:8000/api-management/wizard - Wizard de APIs")
    print(f"   üß™ http://localhost:8000/api-management/test - Test de APIs")
    print(f"")
    print(f"üîë CREDENCIALES DE PRUEBA:")
    print(f"   superadmin / superadmin (Super Admin)")
    print(f"   admin / admin (Admin)")
    print(f"   usuario / usuario (User)")

def verify_templates():
    """Verificar que existen los templates necesarios"""
    
    templates_dir = Path("app/frontend/templates")
    
    required_templates = [
        "home.html",
        "auth/login.html", 
        "dashboard.html",
        "dashboard_with_permissions.html"
    ]
    
    print(f"\nüîç Verificando templates:")
    
    all_exist = True
    for template in required_templates:
        template_path = templates_dir / template
        if template_path.exists():
            print(f"   ‚úÖ {template}")
        else:
            print(f"   ‚ùå {template} (FALTA)")
            all_exist = False
    
    return all_exist

def main():
    """Funci√≥n principal"""
    print("üîß ARREGLANDO PROBLEMAS DE AUTENTICACI√ìN EN MAIN.PY")
    print("=" * 60)
    
    # 1. Verificar templates
    templates_ok = verify_templates()
    
    if not templates_ok:
        print("\n‚ö†Ô∏è Algunos templates faltan, pero continuar√©...")
    
    # 2. Arreglar main.py
    fix_main_py_authentication()
    
    # 3. Mostrar endpoints para probar
    test_endpoints()
    
    print(f"\nüéâ AUTENTICACI√ìN ARREGLADA COMPLETAMENTE")
    print(f"")
    print(f"‚úÖ Endpoint ra√≠z √∫nico que redirige correctamente")
    print(f"‚úÖ Dashboard protegido con verificaci√≥n de sesi√≥n")
    print(f"‚úÖ Rutas de gesti√≥n protegidas (requieren admin)")
    print(f"‚úÖ Logout funcional que limpia sesi√≥n")
    print(f"‚úÖ Funciones de autenticaci√≥n centralizadas")
    print(f"")
    print(f"üöÄ AHORA EJECUTA:")
    print(f"   python run.py")
    print(f"")
    print(f"üîó LUEGO VE A:")
    print(f"   http://localhost:8000")
    print(f"")
    print(f"üí° FLUJO ESPERADO:")
    print(f"   1. http://localhost:8000/ ‚Üí muestra p√°gina de bienvenida")
    print(f"   2. Click en 'Iniciar Sesi√≥n' ‚Üí /login")
    print(f"   3. Login con admin/admin ‚Üí redirige a /dashboard")
    print(f"   4. Dashboard muestra stats reales del sistema")

if __name__ == "__main__":
    main()